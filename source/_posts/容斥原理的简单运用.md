---
title: 容斥原理的简单运用
date: 2021-08-11 14:15:36
index_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-57zvj9.jpg
banner_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-57zvj9.jpg
excerpt: 由一道小题目引发的讨论
math: true
categories:
  - 学习
  - 算法
tags:
  - python
  - c
---

昨天看了一道题，题目大概是甲乙丙分别多少秒放一次鞭炮， 然后问一个时间段里能听到多少响。
其实就是给出三个正整数$n_1, n_2, n_3$，再给一个$n$，问$1\sim n$​秒内有多少个不重复的数被它们其中一个整除。

用集合的语言描述如下
$$
n_1,n_2,n_3,n已知,A=\{k|k \in \mathbb{N} ^*,k\leq n, k|n_1或k|n_2或k|n_3\},求|A|.
$$
为了计算集合$A$​所含元素个数，可以先计算下面三个集合所含元素个数，再减去重复计数的个数
$$
\begin{aligned}
A_1=&\{k|k \in \mathbb{N} ^*,k\leq n, k|n_1\}\\A_2=&\{k|k \in \mathbb{N} ^*,k\leq n, k|n_2\}\\A_3=&\{k|k \in \mathbb{N} ^*,k\leq n, k|n_3\}
\end{aligned}
$$
![图1](https://cdn.jsdelivr.net/gh/suxss/image/2021/绘图1.jpg)

其中$A_1\cap A_2,A_1\cap A_3,A_2\cap A_3$​里的元素被多算了，因此要减去

如果直接减去$|A_1\cap A_2|+|A_1\cap A_3|+|A_2\cap A_3|$​的话，$A_1\cap A_2\cap A_3$里的元素又多减了，因此得加上，

于是，得到公式
$$
|A_1 \cup A_2\cup A_3|=|A_1|+|A_2|+|A_3|-|A_1\cap A_2|-|A_1\cap A_3|-|A_2\cap A_3|+|A_1\cap A_2\cap A_3|
$$
整理一下就是
$$
\left\lvert \bigcup_{i=1}^3 A_i\right\rvert=\sum_{i=1}^3(-1)^{i-1}\left(\sum_{1\leq j_1<\cdots <j_i\leq3}\left\lvert\bigcap_{k=1}^iA_{j_k}\right\rvert\right)
$$
接下来就是去求每一项，其中关键的是求最小公倍数

三个数的最小公倍数可以用两组两个数的最小公倍数表示
$$
[n_1,n_2,n_3]=[[n_1,n_2],[n_2,n_3]]
$$
证明很简单，如下
$$
\begin{aligned}
\forall\space&k,\space k|n_1,k|n_2,k|n_3 ;\\
\because\space &\left\{ {\begin{array}{*{20}{c}}
{k|{n_1}}\\
{k|{n_2}}
\end{array} \Leftrightarrow  k|[{n_1},{n_2}]} \right.\\
\therefore \space&k|[{n_1},{n_2}],k|[{n_1},{n_3}],k|[{n_2},{n_3}]\\
\therefore \space&k|[[n_1,n_2],[n_2,n_3]]
\end{aligned}
$$
由此我们得到 这三个数的任意的公倍数都被$[[n_1,n_2],[n_2,n_3]]$整除

而$[[n_1,n_2],[n_2,n_3]]$显然是$n_1, n_2, n_3$​的公倍数，证毕

而最小公倍数与最大公因数有如下关系
$$
[a,b]\cdot(a,b)=ab
$$
因此要求最小公倍数只需求最大公因数，这就可以用辗转相除法

Python代码如下

```python
def successive_division(a: int, b: int) -> int:  # 辗转相除法
    while a % b != 0:
        a, b = b, a % b
    return b


def least_common_multiple(a: int, b: int) -> int:  # 最小公倍数
    return int(a * b / successive_division(a, b))
```

C语言代码如下

```c
int successive_division(int a, int b) {
    int i = a, j = b, t;
    while (i % j != 0) {
        t = i;
        i = j;
        j = t % j;
    }
    return j;
}

int least_common_multiple(int a, int b) {
    return a * b / successive_division(a, b);
}
```

依靠这个就能写出求解原问题的函数

Python代码如下

```python
def solution(n1: int, n2: int, n3: int, n: int) -> int:
    result = n // n1 + n // n2 + n // n3
    result -= n // least_common_multiple(n1, n2) + n // least_common_multiple(n1, n3) + n // least_common_multiple(n2, n3)
    result += n // least_common_multiple(least_common_multiple(n1, n2), least_common_multiple(n1, n3))
    return result
```

C语言代码如下

```c
int solution(int n1, int n2, int n3, int n) {
    int result = 0;
    result += n / n1 + n / n2 + n / n3;
    result -= n / least_common_multiple(n1, n2) + n / least_common_multiple(n1, n3) + n / least_common_multiple(n2, n3);
    result += n / least_common_multiple(least_common_multiple(n1, n2), least_common_multiple(n1, n3));
    return result;
}
```





