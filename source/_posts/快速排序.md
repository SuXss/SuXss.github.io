---
title: 快速排序（一）
date: 2021-08-09 15:04:07
index_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-pkj789.jpg
banner_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-pkj789.jpg
excerpt: 闲着无聊
categories:
  - 学习
  - 算法
tags:
  - python
---

最近借了些书，有本叫做<u>算法与程序设计(Python)</u>，然而里面300页只有80页在讲算法，大部分在讲Python基础，有种被骗了的感觉😞

算法部分也很多都是很基础的内容。

里面有一个讲的是快速排序，快排的大名可以说是早有耳闻了😄，但是一直没学，上学期自己去看了下大致的原理，但是没空把实现的代码写出来，也懒得去找代码。看到这本书里有快排，我满怀希望地翻到这一部分，才发现并没有给出实现的代码，也是讲了一下原理，给了大致的伪代码。现在正好无聊，就试着根据原理写写这个实现代码。

---

因为对Python比较熟，而且Python语法更简单，就先写快排的Python实现

```python
def quick_sort(num_list: list) -> list:
    if len(num_list) > 1:  # 如果长度等于1就不用排序，直接返回
        x = len(num_list)//2  # 随便找一个参考数
        list_1 = []  # list_1里放比参考数小的
        list_2 = []  # list_2里放比参考数大的
        for item in num_list:
            if item < num_list[x]:
                list_1.append(item)
            else:
                list_2.append(item)
        # 函数递归，分别对list_1,list_2进行快速排序，再合并起来
        sorted_list = quick_sort(list_1)
        sorted_list.append(num_list[x])
        sorted_list.extend(quick_sort(list_2))
        return sorted_list
    else:
        return num_list
```

一开始很顺利的写了出来，然而运行出了问题

测试代码如下

```python
if __name__ == '__main__':
    a = [2, 1, 6, 3, 2, 8, 1]
    b = quick_sort(a)
    print(b)
```

运行后，程序报错如下

```
Traceback (most recent call last):
  File "****\main.py", line 20, in <module>
    b = quick_sort(a)
  File "****\main.py", line 11, in quick_sort
    sorted_list = quick_sort(list_1)
  File "****\main.py", line 11, in quick_sort
    sorted_list = quick_sort(list_1)
  File "****\main.py", line 12, in quick_sort
    sorted_list.extend(quick_sort(list_2))
  File "****\main.py", line 12, in quick_sort
    sorted_list.extend(quick_sort(list_2))
  File "****\main.py", line 12, in quick_sort
    sorted_list.extend(quick_sort(list_2))
  [Previous line repeated 992 more times]
  File "****\main.py", line 11, in quick_sort
    sorted_list = quick_sort(list_1)
  File "****\main.py", line 2, in quick_sort
    if len(num_list) > 1:
RecursionError: maximum recursion depth exceeded while calling a Python object

进程已结束，退出代码为 1
```

其中问题的翻译如下

```
RecursionError：调用 Python 对象时超出了最大递归深度
```

上网查了一下

Python递归深度最多1000

但是我这里测试用的列表`a`的长度为7，按理说正常运行不会超过1000的递归深度，于是我加了打印代码，看看排序的过程如何

```python
print(f"list_1:{list_1}")
print(f"x:{x}")
print(f"list_2:{list_2}")
```

输出显示当有两个数相同时(如下)会一直重复的递归

```python
list_1:[]
x:1
list_2:[1, 1]
```

于是想到排序的过程中加入第三个列表，放置与参考数相同的数

改进的代码如下

```python
def quick_sort(num_list: list) -> list:
    if len(num_list) > 1:
        x = len(num_list)//2
        list_1 = []
        list_3 = []
        list_2 = []
        for item in num_list:
            if item < num_list[x]:
                list_1.append(item)
            elif item > num_list[x]:
                list_2.append(item)
            else:
                list_3.append(item)
        sorted_list = quick_sort(list_1)
        sorted_list.extend(list_3)
        sorted_list.extend(quick_sort(list_2))
        return sorted_list
    else:
        return num_list
```

成功运行，结果如下

```
[1, 1, 2, 2, 3, 6, 8]
```

---

这还不够，如果测试数据大一些呢？能否正常运行？

为此，引入`random`库，继续对函数进行测试，测试代码如下

```python
if __name__ == '__main__':
    import random
    n = 10000
    a = []
    for i in range(n):
        a.append(random.randint(1, n))
    b = quick_sort(a)
    print(b)
```

1万个数排序起来好像确实挺快的，瞬间出结果，总所周知Python的运行速度是比较慢的，所以还是挺意外的

---

下面进一步测试快排的性能

将其与选择排序和冒泡排序进行比较

选择排序代码如下

```python
def select_sort(num_list: list) -> list:
    for i in range(len(num_list)):
        j = num_list[i:].index(min(num_list[i:])) + i
        num_list[i], num_list[j] = num_list[j], num_list[i]
    return num_list
```

冒泡排序代码如下

```python
def bubble_sort(num_list: list) -> list:
    for i in range(len(num_list)):
        for j in range(i + 1, len(num_list)):
            if num_list[i] > num_list[j]:
                num_list[i], num_list[j] = num_list[j], num_list[i]
    return num_list
```

测试代码如下

```python
if __name__ == '__main__':
    import random
    import time
    
    n = 10000
    a = []
    for i in range(n):
        a.append(random.randint(1, n))

    t1 = time.time()
    b = quick_sort(a)
    t2 = time.time()
    print(f"quick_sort:{t2-t1}s")

    t1 = time.time()
    c = select_sort(a)
    t2 = time.time()
    print(f"select_sort:{t2 - t1}s")

    t1 = time.time()
    d = bubble_sort(a)
    t2 = time.time()
    print(f"bubble_sort:{t2 - t1}s")
```

运行结果如下

```python
quick_sort:0.013994216918945312s  # 快速排序
select_sort:0.8812062740325928s  # 选择排序
bubble_sort:2.001237630844116s  # 冒泡排序
```

从结果来看快速排序通常情况下确实要比另外两种排序方法快的

---

完整代码如下

```python
def quick_sort(num_list: list) -> list:
    if len(num_list) > 1:
        x = len(num_list)//2
        list_1 = []
        list_3 = []
        list_2 = []
        for item in num_list:
            if item < num_list[x]:
                list_1.append(item)
            elif item > num_list[x]:
                list_2.append(item)
            else:
                list_3.append(item)
        sorted_list = quick_sort(list_1)
        sorted_list.extend(list_3)
        sorted_list.extend(quick_sort(list_2))
        return sorted_list
    else:
        return num_list


def select_sort(num_list: list) -> list:
    for i in range(len(num_list)):
        j = num_list[i:].index(min(num_list[i:]))+i
        num_list[i], num_list[j] = num_list[j], num_list[i]
    return num_list


def bubble_sort(num_list: list) -> list:
    for i in range(len(num_list)):
        for j in range(i + 1, len(num_list)):
            if num_list[i] > num_list[j]:
                num_list[i], num_list[j] = num_list[j], num_list[i]
    return num_list


if __name__ == '__main__':
    import random
    import time
    n = 10000
    a = []
    for i in range(n):
        a.append(random.randint(1, n))

    t1 = time.time()
    b = quick_sort(a)
    t2 = time.time()
    print(f"quick_sort:{t2-t1}s")

    t1 = time.time()
    c = select_sort(a)
    t2 = time.time()
    print(f"select_sort:{t2 - t1}s")

    t1 = time.time()
    d = bubble_sort(a)
    t2 = time.time()
    print(f"bubble_sort:{t2 - t1}s")

```

