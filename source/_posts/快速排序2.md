---
title: 快速排序（二）
date: 2021-08-10 17:20:38
index_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-7215ry.jpg
banner_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-7215ry.jpg
excerpt: 书接上回以及Python与C性能比较
categories:
  - 学习
  - 算法
tags:
  - python
  - c
---

昨天看着原理大致地写了写快速排序的Python实现。主要是把原列表分成了三块：小于参考数的、等于参考数的、大于参考数的。

遍历列表，看看每个数属于哪一类，接着将它们分别放入三个列表中，对其中不等于参考数的两个列表运用函数递归排序后在拼接起来。

用Python可以很方便的实现，因为Python的变量所占用的内存空间不是恒定不变的，在列表上的体现就是创建一个新列表时不需要声明其长度。而大部分语言在声明变量时就要为其分配一个固定大小的内存空间，体现在列表（或者数组）上就是其长度在一开始就是固定的。当然可以在一开始就设置成长度足够大的列表（或数组），然而这样必然会很大比例的内存空间浪费。因此，如果要直接将昨天的代码改写成其他语言，基本上是运行效率不高的。于是，今天来试着改一改昨天的代码。



## Python代码的改写

昨天的快速排序代码如下

```python
def quick_sort_1(num_list: list) -> list:
    if len(num_list) > 1:
        x = len(num_list)//2
        list_1 = []
        list_3 = []
        list_2 = []
        for item in num_list:
            if item < num_list[x]:
                list_1.append(item)
            elif item > num_list[x]:
                list_2.append(item)
            else:
                list_3.append(item)
        sorted_list = quick_sort_1(list_1)
        sorted_list.extend(list_3)
        sorted_list.extend(quick_sort_1(list_2))
        return sorted_list
    else:
        return num_list
```

关键在于如何修改，划分原列表，使其分为多个部分。

这里给出三种基于在原列表上交换两数的方法

- 第一种

```python
def quick_sort_2(num_list: list) -> list:
    i = 0
    j = len(num_list) - 1
    if j > i:
        x = num_list[i]
        while i < j:
            while num_list[j] >= x and i < j:
                j -= 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                i += 1
            while num_list[i] <= x and i < j:
                i += 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                j -= 1
        sorted_list = quick_sort_2(num_list[:i])
        sorted_list.append(num_list[i])
        sorted_list.extend(quick_sort_2(num_list[i+1:]))
        return sorted_list
    else:
        return num_list
```

- 第二种

```python
def quick_sort_3(num_list: list, left, right) -> list:
    i = left
    j = right
    if j > i:
        x = num_list[i]
        while i < j:
            while num_list[j] >= x and i < j:
                j -= 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                i += 1
            while num_list[i] <= x and i < j:
                i += 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                j -= 1
        sorted_list = quick_sort_3(num_list, left, i-1)
        sorted_list.append(num_list[i])
        sorted_list.extend(quick_sort_3(num_list, i+1, right))
        return sorted_list
    else:
        return num_list[left: right+1]
```

- 第三种

```python
def quick_sort_4(num_list: list) -> list:
    i = 0
    j = len(num_list) - 1
    if j > i:
        x = num_list[i]
        while i < j:
            while num_list[j] >= x and i < j:
                j -= 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                i += 1
            while num_list[i] <= x and i < j:
                i += 1
            if i < j:
                num_list[i], num_list[j] = num_list[j], num_list[i]
                j -= 1
        sorted_list = quick_sort_4(num_list[:j])
        sorted_list.extend(num_list[j:i+1])
        sorted_list.extend(quick_sort_4(num_list[i+1:]))
        return sorted_list
    else:
        return num_list
```

运行速度和昨天的都差不多



## 改写为C语言

将上面第二种方法改写为C语言，代码如下
```c
void quick_sort(int a[], int left, int right)
{
    int i=left, j=right, x, t;
    if(j > i){
        x = *(a+i);
        while (i < j){
            while (*(a+(j)) >= x && i < j)
                j--;
            if(i < j){
                t = *(a+i);
                *(a+(i++)) = *(a+j);
                *(a+j) = t;
            }
            while (*(a+i) <= x && i < j)
                i++;
            if(i < j){
                t = *(a+i);
                *(a+i) = *(a+j);
                *(a+(j--)) = t;
            }
        }
        quick_sort(a, left, i-1);
        quick_sort(a, i+1, right);
    }
}
```

由于C语言速度太快了，所以这次测试10万个数的排序

完整测试代码如下

```c
#include "stdio.h"
#include<stdlib.h>
#include<time.h>

#define N 100000

void pprint(int a[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d  ", *(a + i));
    puts("");
}

void quick_sort(int a[], int left, int right) {
    int i = left, j = right, x, t;
    if (j > i) {
        x = *(a + i);
        while (i < j) {
            while (*(a + (j)) >= x && i < j)
                j--;
            if (i < j) {
                t = *(a + i);
                *(a + (i++)) = *(a + j);
                *(a + j) = t;
            }
            while (*(a + i) <= x && i < j)
                i++;
            if (i < j) {
                t = *(a + i);
                *(a + i) = *(a + j);
                *(a + (j--)) = t;
            }
        }
        quick_sort(a, left, i - 1);
        quick_sort(a, i + 1, right);
    }
}

int main() {
    srand((unsigned) time(NULL));
    int a[N] = {0,};
    double duration;
    time_t start_time, end_time;
    for (int i = 0; i < N; ++i)
        *(a + i) = rand() % N;
//    pprint(a, N);
    start_time = clock();
    quick_sort(a, 0, N);
    end_time = clock();
    duration = (double) (end_time - start_time) / CLK_TCK;
    printf("%lfs\n", duration);
//    pprint(a, N);
    return 0;
}
```

运行结果如下

```
0.011000s

进程已结束，退出代码为 0
```

昨天Python的快速排序**1万**个数需要大概**0.015**秒与C语言快速排序**10万**个所花时间差不多



## Python代码的优化

Python版本的快速排序排序10万个数的运行时间如下

```
quick_sort:0.16658687591552734s
```

Python的功能是十分强大的，但是居然落后这么多，让我十分不甘心。

下面我们来优化Python版本的代码



### 1.把所有变量都转为局部变量

直接把之前`if __name__ == '__main__':`里的语句写入`main`函数

```python
def main():
    from random import randint
    from time import time
    n = 100000
    a = []
    for i in range(n):
        a.append(randint(1, n))

    t1 = time()
    c = quick_sort(a)
    t2 = time()
    print(f"quick_sort:{t2 - t1}s")
```

优化结果

```
quick_sort:0.15358948707580566s
```

效果不是很明显



### 2.使用pypy3

运行结果

```
quick_sort:0.023967981338500977s
```

大约快了8倍，多次运行发现快的可以到`0.02s`



### 3.其他

加速python代码的方法还有很多种

比如可以将代码文件转为pyo，pyd文件

像这里还可以使用numpy库

但是我这里的代码用了较多的extend和append方法，如果用array无法实现数组原地修改，因此如果直接用的话速度反而会降下来



其实Python里列表排序可以直接使用sort方法

代码如下

```python
from random import randint
from time import time
n = 100000
a = []
for i in range(n):
a.append(randint(1, n))
t1 = time()
a.sort()
t2 = time()
print(f"quick_sort:{t2 - t1}s")
```

使用pypy3运行，运行时间为`0.010~0.011s`左右，与C语言持平
