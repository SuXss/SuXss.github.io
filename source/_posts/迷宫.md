---
title: 迷宫
date: 2021-08-17 18:33:05
index_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/work.jpg
banner_img: https://cdn.jsdelivr.net/gh/suxss/image/2021/wallhaven-m9wgx81.jpg
excerpt: 论如何把幼儿园题目做出高级感
categories:
  - 学习
  - 算法
tags:
  - python
---

# 前言
最近看了道题，题目感觉还蛮好玩的，就做了做



# 题目

```
下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。
010000
000100
001001
110000
迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。
对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R
分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，
其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。
 请注意在字典序中D<L<R<U。
```

题目中的复杂迷宫如下

```
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
```

# 分析

其实题目很简单，就是幼儿园小学的小朋友玩的迷宫

因此只需要把图画出来（比如用Excel, Python）

然后找最短通路就行了

但是，这种方法很不高级

用编程的方法解决它更有意思



# 解法

题目比较简单，就不多解释代码了

主要用到了广度优先，本质上是穷举

每条路每次都走一步，谁先到终点谁就是最短路径

为了避免重复，引入集合`history`记录历史走过的地点，其中的关键是这个历史是每条路共享的，如果其中有一条路A走到了路B或者自己之前走过的位置上，那路A肯定不是最短路径

代码如下

```python
map = .... # 30 x 50 的矩阵

# DLRU
way = {'place': 0, 'str': ''}
ways = [way, ]
history = {0, }

while len(ways):
    new_ways = []
    for item in ways:
        x, y = item['place'] // 50, item['place'] % 50
        if (x, y) == (29, 49):
            print(item['str'])
            print(len(item['str']))
            break
        if item['place'] + 50 not in history and x < 29 and not map[x+1][y]:
            new_way = {'place': item['place'] + 50, 'str': item['str'] + 'D'}
            new_ways.append(new_way)
            history.add(new_way['place'])
        if item['place'] - 1 not in history and y > 0 and not map[x][y-1]:
            new_way = {'place': item['place'] - 1, 'str': item['str'] + 'L'}
            new_ways.append(new_way)
            history.add(new_way['place'])
        if item['place'] + 1 not in history and y < 49 and not map[x][y+1]:
            new_way = {'place': item['place'] + 1, 'str': item['str'] + 'R'}
            new_ways.append(new_way)
            history.add(new_way['place'])
        if item['place'] - 50 not in history and x > 0 and not map[x-1][y]:
            new_way = {'place': item['place'] - 50, 'str': item['str'] + 'U'}
            new_ways.append(new_way)
            history.add(new_way['place'])
    ways = new_ways

```

结果如下

```
DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR
186

```



# 可视化

进一步将寻路过程可视化，结果如下




![](https://cdn.jsdelivr.net/gh/suxss/image/2021/test-min.gif)



可视化代码

- 1

```python
# 画地图
import PIL
import numpy

map = ...


def bigger(matrix, n):
    x = matrix.shape[0]
    y = matrix.shape[1]
    bigmap = numpy.zeros((x*n, y*n), dtype=numpy.bool_)
    for i in range(x):
        for j in range(y):
            if map[i, j]:
                bigmap[n * i:n * i + n, n * j:n * j + n] = numpy.matrix(numpy.ones((n, n)))
    return bigmap


map = numpy.array(map, dtype=numpy.bool_)
map = numpy.matrix(map)
for i in range(30):
    for j in range(50):
        map[i, j] = 0 if map[i, j] else 1

bigmap = bigger(map, 25)

new_map = PIL.Image.fromarray(bigmap)
new_map.show()
new_map.save('map.png')
```

- 2

```python
# 画每一帧的图像
import turtle


map = ...


def bgpic(self, picname=None):
    if picname is None:
        return self._bgpicname
    if picname not in self._bgpics:
        self._bgpics[picname] = self._image(picname)
    self._setbgpic(self._bgpic, self._bgpics[picname])
    self._bgpicname = picname


def D(x, y):
    return x-782+160, y+467-160+67


def down():
    global current
    x, y = current[0], current[1]
    turtle.goto(D(x, y-25))
    current = [x, y-25]


def up():
    global current
    x, y = current[0], current[1]
    turtle.goto(D(x, y+25))
    current = [x, y + 25]


def left():
    global current
    x, y = current[0], current[1]
    turtle.goto(D(x-25, y))
    current = [x - 25, y]


def right():
    global current
    x, y = current[0], current[1]
    turtle.goto(D(x+25, y))
    current = [x + 25, y]


def parse_way(way):
    for i in range(len(way)):
        if way[i] == 'D':
            down()
        elif way[i] == 'U':
            up()
        elif way[i] == 'L':
            left()
        elif way[i] == 'R':
            right()
    turtle.penup()
    turtle.goto(D(12, -12))
    turtle.pendown()
    global current
    current = [12, -12]

def first():
    myWin = turtle.Screen()
    turtle.setup(width=1250, height=750, startx=0, starty=0)
    turtle.bgpic(r'map.png')  # 这样设置。
    turtle.speed(10)
    turtle.penup()
    turtle.setposition(D(12, -12))
    turtle.pensize(5)
    turtle.pendown()
    turtle.colormode(255)
    turtle.pencolor(255, 0, 0)

    global current
    current = [12, -12]


def save(num):
    # 保存
    ts = turtle.getscreen()
    ts.getcanvas().postscript(file="work.eps")
    from PIL import Image

    im = Image.open("work.eps")
    im.save(f"./images/work_{num}.jpg")
    turtle.clear()


if __name__ == '__main__':
    first()

    way = {'place': 0, 'str': ''}
    ways = [way, ]
    history = {0, }
    s = 0

    while len(ways):
        new_ways = []
        for item in ways:
            x, y = item['place'] // 50, item['place'] % 50
            if (x, y) == (29, 49):
                print(item['str'])
                print(len(item['str']))
                break
            if item['place'] + 50 not in history and x < 29 and not map[x + 1][y]:
                new_way = {'place': item['place'] + 50, 'str': item['str'] + 'D'}
                new_ways.append(new_way)
                history.add(new_way['place'])
            if item['place'] - 1 not in history and y > 0 and not map[x][y - 1]:
                new_way = {'place': item['place'] - 1, 'str': item['str'] + 'L'}
                new_ways.append(new_way)
                history.add(new_way['place'])
            if item['place'] + 1 not in history and y < 49 and not map[x][y + 1]:
                new_way = {'place': item['place'] + 1, 'str': item['str'] + 'R'}
                new_ways.append(new_way)
                history.add(new_way['place'])
            if item['place'] - 50 not in history and x > 0 and not map[x - 1][y]:
                new_way = {'place': item['place'] - 50, 'str': item['str'] + 'U'}
                new_ways.append(new_way)
                history.add(new_way['place'])
        first()
        for item in new_ways:
            parse_way(item['str'])
        s += 1
        save(s)
        ways = new_ways
```

- 3

```python
# 将图像转化为gif动画与mp4视频
import cv2
import os
import imageio


def pic_to_video(pic_list, video_name, fps, pic_size):
    if "mp4" in video_name:
        video = cv2.VideoWriter(video_name, cv2.VideoWriter_fourcc(*'mp4v'), fps, pic_size)
    elif ".avi" in video_name:
        video = cv2.VideoWriter(video_name, cv2.VideoWriter_fourcc(*'DIVX'), fps, pic_size)
    else:
        print("格式错误")
        return

    for filename in pic_list:
        if os.path.exists(filename):
            video.write(cv2.imread(filename))
    video.release()


def compose_gif(img_paths):
    gif_images = []
    for path in img_paths:
        gif_images.append(imageio.imread(path))
    imageio.mimsave("test.gif", gif_images, fps=10)


if __name__ == "__main__":
    image_list = [f'./images/work_{i}.jpg' for i in range(1, 187)]
    compose_gif(image_list)
    pic_to_video(image_list, "test.mp4", 10, (935, 562))

```

